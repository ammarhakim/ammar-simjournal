/* Poisson solver based on recovery approach */

load("modal-basis")$
load("basis-precalc/basisSer2x")$
load("recovery-calc/recovery")$

/* Function to project function on DG basis */
projectOnBasisGrid(func, bc, xL, xR, yL, yR, NX, NY) := block([dx,dy],
  dx : (xR-xL)/NX,
  dy : (yR-yL)/NY,
  return (
    makelist(
      makelist(
        calcInnerProdList([x,y],1,bc,
          subst([z=x*dx/2+(xL+(i-1/2)*dx),w=y*dy/2+(yL+(j-1/2)*dy)], apply(func, [z,w]))),
        j, 1, NY),
      i, 1, NX)
    )
  )$

/* Function to compute L2 norm of field */
calcL2Norm(dgField, dx, dy) := block([NX,NY,NC,l2s],
  NX : length(dgField),
  NY : length(dgField[1]),
  NC : length(dgField[1][1]),
  l2s : 0,
  for i : 1 thru NX do (
    for j : 1 thru NY do (
      l2s : l2s+sum(dgField[i][j][k]^2,k,1,NC)
      )
    ),
  return (dx*dy*l2s/4)
  )$

/* Function to compute Laplacian stencil in 2D */
getLaplacianStencil(basisNm, polyOrder, fL, fC, fR, fB, fT) := calcInnerProdList([x,y], 1,
  getBasis(sconcat("basis-precalc/basis", basisNm, "2x"), polyOrder),
  diff(calcRecov3CellGen(basisNm, x, [2,2], polyOrder, 1, fL, fC, fR), x, 2) +
  diff(calcRecov3CellGen(basisNm, y, [2,2], polyOrder, 1, fB, fC, fT), y, 2)
  )$

/* Transform to [-1,1] */
xe(eta,dx,xj)  := eta*dx/2+xj$

/*
* grid: grid(lower=[xl,yl], upper=[xr,yr],cells=[NX,NY])
*
* bcLeft/bcRight, bcTop/bcBottom: BC(type=1, value=0)
*
*    type can be 1 (Dirichlet) or 2 (Neumann). Value muust be a number
*/
solvePoissonEquation(grid, polyOrder, srcFunc, bcLeft, bcRight, bcBottom, bcTop) := block(
  /* Declare local variables */
  [
  NC, xL, xR, dx, nmax, slist, h, stencilI, hL, stenciL, hR, stencilR, eqnList,
  varList, fsol, isPeriodic,
  bcType, bcValue, srcMean
  ],
  
  bc : basisC[polyOrder],
  NC : length(bc),
  xL : assoc(lower,grid),
  xR : assoc(upper,grid),
  nmax : assoc(cells,grid),
  dx : (xR-xL)/nmax, /* Cell spacing */
  
  /* Source function on [-1,1] */
  srcFuncHat(eta,dx,xj) := srcFunc(xe(eta,dx,xj)),
  /* Check if periodic direction */
  isPeriodic : assoc(isPeriodic,grid),
  /* Substitution list for indexing ... */
  slist : append(
    /* x-direction for f ... */
    makelist(fL[k]=f[i-1,k],k,1,NC),
    makelist(fC[k]=f[i,k],k,1,NC),
    makelist(fR[k]=f[i+1,k],k,1,NC)
    ),
  /* ... for periodic BCs */
  pBc : append(
    /* for f ... */
    makelist(f[0,k]=f[nmax,k],k,1,NC),
    makelist(f[nmax+1,k]=f[1,k],k,1,NC)
    ),
  
  /* Compute second derivative */
  h : getRecov3CellGen(x, [2], polyOrder, 1, fL, fC, fR),
  /* Construct list of equations */
  if isPeriodic then (
    srcMean : integrate(srcFunc(x),x,xL,xR)/(xR-xL),
    /* Interior stencil */
    stencilI : subst(slist,
      calcInnerProdList([x], 1, bc, diff(h,x,2))
      ),
    eqnList : [], /* List of equations */
    /* Construct set of linear equations for interior */
    for j : 1 thru nmax do (
      eqnList : append(eqnList,
        4/dx^2*subst(i=j,stencilI)-calcInnerProdList([x],1,bc,-(srcFuncHat(x,dx,xL+(j-1/2)*dx)-srcMean))
        )
      ),
    /* Apply periodic BCs */
    eqnList : subst(pBc, eqnList),
    /* Set cell-average term in first skin cell to zero to avoid singular inversion */
    eqnList : rest(append(eqnList, [f[1,1]=0])) /* remove one equation */
    )
  else (
    /* Interior stencil */
    stencilI : subst(slist,
      calcInnerProdList([x], 1, bc, diff(h,x,2))
      ),
    /* Stencils for left/right skin cells */
    bcType : assoc(type,bcLeft),
    bcValue : assoc(value,bcLeft),
    hL : getRecov3CellGen(x, [2], polyOrder, 1, bcValue, fC, fR, [bcType,0]),
    stencilL : subst(subst(i=1,slist),
      calcInnerProdList([x], 1, bc, diff(hL,x,2))
      ),
    bcType : assoc(type,bcRight),
    bcValue : assoc(value,bcRight),
    /* Right skin cell stencil */
    hR : getRecov3CellGen(x, [2], polyOrder, 1, fL, fC, bcValue, [0,bcType]),
    stencilR : subst(subst(i=nmax,slist),
      calcInnerProdList([x], 1, bc, diff(hR,x,2))
      ),
    eqnList : [], /* List of equations */
    /* Construct set of linear equations for interior */
    for j : 2 thru nmax-1 do (
      eqnList : append(eqnList,
        4/dx^2*subst(i=j,stencilI)-calcInnerProdList([x],1,bc,-srcFuncHat(x,dx,xL+(j-1/2)*dx))
        )
      ),
    /* Equations in left/right skin cells */
    eqnList : append(eqnList,
      4/dx^2*subst(i=1,stencilL)-calcInnerProdList([x],1,bc,-srcFuncHat(x,dx,xL+(1-1/2)*dx))
      ),
    eqnList : append(eqnList,
      4/dx^2*subst(i=nmax,stencilR)-calcInnerProdList([x],1,bc,-srcFuncHat(x,dx,xL+(nmax-1/2)*dx))
      )
    ),
  
  /* List of unknowns */
  varList : [],
  for i : 1 thru nmax do (
    varList : append(varList, makelist(f[i,k],k,1,NC))
    ),
  /* Solve linear system */
  fSol : linsolve(eqnList, varList),
  /* Return solution field */
  return (
    subst(fSol, makelist(makelist(f[i,k],k,1,NC), i, 1, nmax))
    )
  )$




