/* Poisson solver based on recovery approach */

load("modal-basis")$
load("basis-precalc/basisSer1x")$
load("recovery-calc/recovery")$

/* Function to make agruments to draw2d() function */
createArgListDgSol(dgField, clr, xL, xR) := block([dx,argList,xj,N],
  N : length(dgField),
  dx : (xR-xL)/N,
  argList : [grid=true, color=clr],
  for i : 1 thru N do (
    xj : xL+(i-1/2)*dx,
    argList : endcons(explicit(
        dgField[i].subst(x=(z-xj)/(dx/2),bc),z,xL+(i-1)*dx,xL+i*dx),
      argList)
    ),
  return(argList)
  )$

/* Function to project function on DG basis */
projectOnBasisGrid(func, bc, xL, xR, N) := block([dx],
  dx : (xR-xL)/N,
  return (
    makelist(
      calcInnerProdList([x],1,bc,
        subst(z=x*dx/2+(xL+(i-1/2)*dx), apply(func, [z]))),
      i, 1, N)
    )
  )$

/* Function to subtract value from first element in list of list */
subVal(dgField, val) := block([outList],
  outList : copylist(dgField),
  for i : 1 thru length(dgField) do (
    outList[i][1] : dgField[i][1]-val
    ),
  return(outList)
  )$

/* Function to compute L2 norm of field */
calcL2Norm(dgField, dx) := sqrt(dx*sum(sum(dgField[i][k]^2,k,1,length(dgField[1])), i, 1, length(dgField)))$

/* Transform to [-1,1] */
xe(eta,dx,xj)  := eta*dx/2+xj$

/*
* grid: grid(lower=xl, upper=xr,cells=N,isPeriodic=false)
*
*    isPeriodic is optional
*
* bcLeft/bcRight: BC(type=1, value=0)
*
*    type can be 1 (Dirichlet) or 2 (Neumann). Value muust be a number
*/
solvePoissonEquation(grid, polyOrder, srcFunc, bcLeft, bcRight) := block(
  /* Declare local variables */
  [
  bc, NC, xL, xR, dx, nmax, slist, h, stencilI, hL, stenciL, hR, stencilR, eqnList,
  varList, fsol, isPeriodic,
  bcType, bcValue, srcMean
  ],
  
  bc : basisC[polyOrder],
  NC : length(bc),
  xL : assoc(lower,grid),
  xR : assoc(upper,grid),
  nmax : assoc(cells,grid),
  dx : (xR-xL)/nmax, /* Cell spacing */
  
  /* Source function on [-1,1] */
  srcFuncHat(eta,dx,xj) := srcFunc(xe(eta,dx,xj)),
  /* Check if periodic direction */
  isPeriodic : assoc(isPeriodic,grid),
  /* Substitution list for indexing ... */
  slist : append(
    /* x-direction for f ... */
    makelist(fL[k]=f[i-1,k],k,1,NC),
    makelist(fC[k]=f[i,k],k,1,NC),
    makelist(fR[k]=f[i+1,k],k,1,NC)
    ),
  /* ... for periodic BCs */
  pBc : append(
    /* for f ... */
    makelist(f[0,k]=f[nmax,k],k,1,NC),
    makelist(f[nmax+1,k]=f[1,k],k,1,NC)
    ),
  
  /* Compute second derivative */
  h : getRecov3CellGen(x, [2], polyOrder, 1, fL, fC, fR),
  /* Construct list of equations */
  if isPeriodic then (
    srcMean : integrate(srcFunc(x),x,xL,xR)/(xR-xL),
    /* Interior stencil */
    stencilI : subst(slist,
      calcInnerProdList([x], 1, bc, diff(h,x,2))
      ),
    eqnList : [], /* List of equations */
    /* Construct set of linear equations for interior */
    for j : 1 thru nmax do (
      eqnList : append(eqnList,
        4/dx^2*subst(i=j,stencilI)-calcInnerProdList([x],1,bc,-(srcFuncHat(x,dx,xL+(j-1/2)*dx)-srcMean))
        )
      ),
    /* Apply periodic BCs */
    eqnList : subst(pBc, eqnList),
    /* Set cell-average term in first skin cell to zero to avoid singular inversion */
    eqnList : rest(append(eqnList, [f[1,1]=0])) /* remove one equation */
    )
  else (
    /* Interior stencil */
    stencilI : subst(slist,
      calcInnerProdList([x], 1, bc, diff(h,x,2))
      ),
    /* Stencils for left/right skin cells */
    bcType : assoc(type,bcLeft),
    bcValue : assoc(value,bcLeft),
    hL : getRecov3CellGen(x, [2], polyOrder, 1, bcValue, fC, fR, [bcType,0]),
    stencilL : subst(subst(i=1,slist),
      calcInnerProdList([x], 1, bc, diff(hL,x,2))
      ),
    bcType : assoc(type,bcRight),
    bcValue : assoc(value,bcRight),
    /* Right skin cell stencil */
    hR : getRecov3CellGen(x, [2], polyOrder, 1, fL, fC, bcValue, [0,bcType]),
    stencilR : subst(subst(i=nmax,slist),
      calcInnerProdList([x], 1, bc, diff(hR,x,2))
      ),
    eqnList : [], /* List of equations */
    /* Construct set of linear equations for interior */
    for j : 2 thru nmax-1 do (
      eqnList : append(eqnList,
        4/dx^2*subst(i=j,stencilI)-calcInnerProdList([x],1,bc,-srcFuncHat(x,dx,xL+(j-1/2)*dx))
        )
      ),
    /* Equations in left/right skin cells */
    eqnList : append(eqnList,
      4/dx^2*subst(i=1,stencilL)-calcInnerProdList([x],1,bc,-srcFuncHat(x,dx,xL+(1-1/2)*dx))
      ),
    eqnList : append(eqnList,
      4/dx^2*subst(i=nmax,stencilR)-calcInnerProdList([x],1,bc,-srcFuncHat(x,dx,xL+(nmax-1/2)*dx))
      )
    ),
  
  /* List of unknowns */
  varList : [],
  for i : 1 thru nmax do (
    varList : append(varList, makelist(f[i,k],k,1,NC))
    ),
  /* Solve linear system */
  fSol : linsolve(eqnList, varList),
  /* Return solution field */
  return (
    subst(fSol, makelist(makelist(f[i,k],k,1,NC), i, 1, nmax))
    )
  )$




